{% include "getch/pixloader.html" %}

<style>
  .post {
    background: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  .post .backbone {
    border-collapse: collapse;
  }

  .post .backbone td {
    position: relative;
    padding: 0;
    box-sizing: border-box;
    border: var(--border);
    text-align: center;
    transition: all 0.2s;
  }

  .post .backbone td.full {
    width: var(--s-0);
  }

  .post .backbone td.half {
    width: var(--s-1);
  }

  .post .backbone td.side {
    width: var(--s-menu);
    border-top: none;
    border-bottom: none;
  }

  .post .backbone td.top {
    height: var(--s-0);
  }

  .post .backbone td.bottom {
    border-bottom: none;
    height: calc(var(--s-0) + var(--border-w)/2);
    /* td.bottom의 아래경계선을 지워주면서, 그만큼 높이를 늘렸다 */
  }


  .post .description {
    text-align: right;
    position: absolute;
    top: 20%;
    right: calc(80 * var(--x));
    width: 70%;
    /* transform: translate(0,-50%); */
    font-size: 12px;
    line-height: 1.4;
    pointer-events: none;
    white-space: pre;
  }

  .post .description span {
    background: black;
    color: white;
    padding-left: 2px;
    padding-right: 2px;
    pointer-events: auto;
  }

  .post span.vs {
    position: absolute;
    background: var(--color-pos);
    color: black;
    font-size: var(--vs-fsize);
    line-height: calc(var(--vs-fsize) + 8px);
    font-weight: bold;
  }

  .post[type='postvoteox'] span.vs {
    bottom: var(--s-1);
    left: calc(var(--s-1) + var(--border-w)/2);
    transform: translate(-50%,50%);
  }

  .post[type='postvoteab'] span.vs {
    top: calc(var(--s-0) + var(--border-w)/2);
    left: calc(var(--s-1) + var(--border-w)/2);
    transform: translate(-50%,-50%);
  }

  .post[type='postvoteox'] .backbone .ox {
    width: 100%;
    height: 100%;
    color: black;
    background: none;
    font-weight: bold;
    font-size: var(--ox-fsize);
    display: flex;
    align-items: center;
    justify-content: center;
    /* display: inline-block; */
  }

  .post .scores {
    font-size: 40px;
    font-weight: bold;
    opacity: 1;
    transition: opacity 0.2s;
    pointer-events: none;
  }

  .post .scores .score {
    position: absolute;
    background: none;
    transform: translate(-50%,-50%);
  }

  .post[type='postvoteox'] .scores .score.vote-0 {
    top: calc(var(--s-0) + var(--s-1)/2);
    left: calc(var(--s-1) + var(--border-w)/2 - var(--s-1)/2);
  }

  .post[type='postvoteox'] .scores .score.vote-1 {
    top: calc(var(--s-0) + var(--s-1)/2);
    left: calc(var(--s-1) + var(--border-w)/2 + var(--s-1)/2);
  }

  .post[type='postvoteab'] .scores .score.vote-0 {
    top: calc(var(--s-0) - var(--s-1)/2);
    left: calc(var(--s-1) + var(--border-w)/2);
  }

  .post[type='postvoteab'] .scores .score.vote-1 {
    top: calc(var(--s-0) + var(--s-1)/2);
    left: calc(var(--s-1) + var(--border-w)/2);
  }


  .post .modify.button,
  .post .newpost.button {
    position: absolute;
    bottom: 30px;
    left: 30px;
    width: calc(var(--s-0) + var(--border-w) - 60px);
    height: 35px;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
  }

  .post .modify.button div {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
  }

  .post .modify.button div.edit-post {
    background: black;
    flex-grow: 1
  }

  .post .modify.button div.edit-post.onedit {
    background: orange;
  }

  .post .modify.button div.delete-post {
    background: var(--color-pos);
    width: 35px;
    margin-left: 5px;
  }


  .post .modify.button div.delete-post img {
    width:20px;
    height: 20px;
    object-fit: contain;
    filter: invert(100%);
  }

  .post .newpost.button {
    background: black;
  }

  /* 중요참고: contenteditable은 swiper에서 안먹힌다. swiper에서 detachEvents를 해야한다 */
  .post .description span.text[contenteditable=true]:focus {
    font-size: 20px;
    line-height: 1.3;
    display: inline-flex;
    justify-content: flex-end;
  }

  .post .description span.text[contentEditable=true]:empty::before {
    content: attr(placeholder);
    color: gray;
  }

  .post[type='postvoteab'] .backbone td.devoted {
    filter: grayscale(1);
    opacity: 0.5;
  }

  .post[type='postvoteox'] .backbone td.voted[act='0'] {
    background: var(--color-pos);
  }

  .post[type='postvoteox'] .backbone td.voted[act='1'] {
    background: var(--color-neg);
  }


  .post .show-modify-enter-active,
  .post .show-modify-leave-active,
  .post .show-newpost-enter-active,
  .post .show-newpost-leave-active {
    transition: bottom 0.1s;
  }

  .post .show-modify-enter,
  .post .show-modify-leave-to,
  .post .show-newpost-enter,
  .post .show-newpost-leave-to {
    bottom: -40px !important;
  }
</style>


<script type='text/x-template' id='post-template'>
  <div class='post' :type='post_type' ref='post'>

    <table v-if='post_type=="postvoteox"' class='backbone'>
      <tbody>
        <tr>
          <td class='top full' colspan='2'>
            <pixloader field='pix' :pix='post_pix' :editable='on_edit'></pixloader>
          </td>
          <td class='top side'></td>
        </tr>

        <tr>
          <td class='bottom half' act='0' :class='voted_class_0' @click='toggle_vote'><div class='ox'>O</div></td>
          <td class='bottom half' act='1' :class='voted_class_1' @click='toggle_vote'><div class='ox'>X</div></td>
          <td class='bottom side'></td>
        </tr>
      </tbody>
    </table>

    <table v-if='post_type=="postvoteab"' class='backbone'>
      <tbody>
        <tr>
          <td class='top full' act='0' :class='voted_class_0' @click='toggle_vote'>
            <pixloader field='pix_a' :pix='post_pix_a' :editable='on_edit'></pixloader>
          </td>
          <td class='top side'></td>
        </tr>

        <tr>
          <td class='bottom full' act='1' :class='voted_class_1' @click='toggle_vote'>
            <pixloader field='pix_b' :pix='post_pix_b' :editable='on_edit'></pixloader>
          </td>
          <td class='bottom side'></td>
        </tr>
      </tbody>
    </table>

    <div class='author menublock' @click='session.open_authorpage()'>
      <img class='fit' :src='post_boo_profile_pix'>
    </div>

    <div class='description'>
      <span class='nick'>@[[ post_boo_nick ]]</span><br>
      <span class='text' :asis='post_text' contenteditable="true" spellcheck='false' placeholder='COMMENT HERE'>[[ post_text ]]</span>
    </div>

    <div class='scores' v-if='post'>
      <div class='score vote-0'>[[ post.nvotes_up ]]</div>
      <div class='score vote-1'>[[ post.nvotes_down ]]</div>
    </div>

    <transition name='show-modify'>
      <div class='modify button' v-if='is_mypost'>
        <div class='edit-post' :class='{ onedit: on_edit }' @click='toggle_edit'>[[ edit_button_text ]]</div>
        <div class='delete-post' onclick='delete_post()'>
          <img src='/static/materials/icons/delete.png'>
        </div>
      </div>
    </transition>

    <transition name='show-newpost'>
      <div class='newpost button' v-if='!post' @click='save_post'>SAVE NEWPOST</div>
    </transition>

    <span class='vs'>VS</span>
  </div>
</script>


<script>
  Vue.component('post', {
    template: '#post-template',
    delimiters: ['[[', ']]'],
    props: ['post', 'session', 'type'],

    data: function() {
      return {
        on_edit: (this.post ? false : true)
      }
    },

    computed: {
      post_type: function() {
        if (this.post) {
          return this.post.type
        } else {
          return this.type
        }
      },

      post_pix: function() {
        try { return this.post.pix }
        catch(e) { return '' }
      },

      post_pix_a: function() {
        try { return this.post.pix_a }
        catch(e) { return '' }
      },

      post_pix_b: function() {
        try { return this.post.pix_b }
        catch(e) { return '' }
      },

      post_boo_profile_pix: function() {
        if (this.post) {
          return this.post.boo.profile.pix
        } else {
          return this.session.auth.boo.profile.pix
        }
      },

      post_boo_nick: function() {
        if (this.post) {
          return this.post.boo.nick
        } else {
          return this.session.auth.boo.nick
        }
      },

      post_text: function() {
        if (this.post) {
          return this.post.text
        } else {
          return ''
        }
      },

      vote_state: function() {
        if (this.session.auth && this.post) {
          return this.session.auth.has_voted_as(this.post.id)
        } else {
          return -1
        }
      },

      voted_class_0: function() {
        return {
          voted: (this.vote_state == 0) && this.is_cpost && !this.on_edit,
          devoted: (this.vote_state == 1) && this.is_cpost && !this.on_edit
        }
      },

      voted_class_1: function() {
        return {
          voted: (this.vote_state == 1) && this.is_cpost && !this.on_edit,
          devoted: (this.vote_state == 0) && this.is_cpost && !this.on_edit
        }
      },

      is_cpost: function() {
        if (this.session.cpost && this.post) {
          return (this.session.cpost.id == this.post.id)

        } else {
          return false
        }
      },

      is_mypost: function() {
        return this.session.auth && this.is_cpost && (this.session.auth.boo.id == this.post.boo.id)
      },

      edit_button_text: function() {
        if (this.on_edit) {
          return 'ON EDITING'
        } else {
          return 'EDIT'
        }
      }
    },

    watch: {
      on_edit: function(_new, _old) {
        if (_new) {
          this.session.swiper.detachEvents()
          // this.$emit('freeze');

        } else if (_old) {
          // this.$emit('activate');
          this.session.swiper.attachEvents();
          this.save_post();
        }
      }
    },

    methods: {
      toggle_vote: function(event) {
        if (this.session.auth && this.session.mode.on=='journey' && !this.on_edit) {
          const act = Number(event.currentTarget.getAttribute('act'));

          if (this.vote_state==act) {
            this.rescore(act, -1);
            this.session.auth.vote(this.post.id, -1);

          } else {
            this.rescore(this.vote_state, act);
            this.session.auth.vote(this.post.id, act);
          }
        }
      },

      rescore: function(_old, _new) {
        if (_old==-1 && _new==0) {
          this.post.nvotes_up += 1;

        } else if (_old==-1 && _new==1) {
          this.post.nvotes_down += 1;

        } else if (_old==0 && _new==-1) {
          this.post.nvotes_up -= 1;

        } else if (_old==1 && _new==-1) {
          this.post.nvotes_down -= 1;

        } else if (_old==0 && _new==1) {
          this.post.nvotes_up -= 1;
          this.post.nvotes_down += 1;

        } else if (_old==1 && _new==0) {
          this.post.nvotes_up += 1;
          this.post.nvotes_down -= 1;
        }
      },

      toggle_edit: function() {
        this.on_edit = !this.on_edit;
      },


      save_post: function() {
        const post = this.$refs.post;
        const text = post.querySelector('.description span.text');
        const pixloaders = post.querySelectorAll('input[type="file"]');
        const formdata = new FormData();

        // text가 바뀌는 경우
        if (text.getAttribute('asis')!=text.innerHTML) {
          formdata.append('text', text.innerHTML.replace(/<br>/gi,'\n'));
          text.setAttribute('asis', text.innerHTML);
        }

        // pix가 선택된 경우
        pixloaders.forEach(input => {
          if (input.files.length > 0) {
            formdata.append(input.getAttribute('field'), input.files[0]);
            input.value = '';
          }
        });

        if (formdata.has('text') | formdata.has('pix') | formdata.has('pix_a') | formdata.has('pix_b')) {
          formdata.append('csrfmiddlewaretoken', '{{csrf_token}}');
          formdata.append('type', this.post_type);

          // 포스트를 수정하는 경우
          if (this.post) {
            formdata.append('post_id', this.post.id);
          }

          const self = this;
          fetch('post/save/', { method: 'POST', body: formdata })
            .then(res => res.json())
            .then(js => {
              if (js.success && js.mode=='created') {
                const post = JSON.parse(js.post);
                this.session.push_post(post);
                self.session.close_page();
              }
            });
        }
      }

    }
  });


  function delete_post() {
    fetch(`post/${session.cpost.post_id}/delete`)
      .then(res => res.json())
      .then(js => {
        console.log(js);
      });

    // 경고메시지가 있어야할듯하다
    // 삭제후 액션이 약간 어색한듯
    swiper.slideTo(swiper.realIndex + 1);
    swiper.removeSlide(swiper.realIndex - 1);
    }
</script>
